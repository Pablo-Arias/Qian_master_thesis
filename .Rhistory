# 创建标准 dyad（双向统一）
df <- df %>%
mutate(dyad_std = ifelse(as.character(user_id) < as.character(other_id),
paste(user_id, other_id, sep = "_"),
paste(other_id, user_id, sep = "_")))
# 只保留 measure（或 relationship）两个方向都存在的数据
df_wide <- df %>%
select(dyad_std, user_id, other_id, question_content, relationship) %>%
pivot_wider(names_from = user_id, values_from = relationship)  # 宽格式转化
# 或者另一种做法：配对并合并成 A→B 和 B→A 两行拼一行
df_paired <- df %>%
select(dyad_std, question_content, user_id, other_id, relationship) %>%
group_by(dyad_std, question_content) %>%
filter(n() == 2) %>%
arrange(dyad_std, question_content, user_id) %>%
mutate(pair_id = paste0(dyad_std, "_", question_content)) %>%
summarise(question_content,
rel1 = first(relationship),
rel2 = last(relationship)
)
df_paired %>%
ggplot(aes(x = rel1, y = rel2)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "rel1",
breaks = c(1:9)) +
scale_y_continuous(name = " rel2",
breaks = c(1:6))
#存表
write.csv(df_paired, "data/behavior/srm/correlation.csv", row.names = FALSE)
write.csv(df_paired, "data/behavior/srm/correlation_group.csv", row.names = FALSE)
correlation(data = df_paired,
select = "rel1",
select2 = "rel2",
method = "spearman",
alternative = "two.sided")
View(df_paired)
library(correlation)
# 只取你要分析的列，构建一个简洁数据框
rel_data  <- df_paired %>% select(rel1, rel2)
# 使用 correlation() 明确说明列名，不让它自动分组
cor_result <- correlation(
data = rel_data,
method = "spearman"
)
print(cor_result)
library(purrr)
# 1. 按 question_content 分组
grouped <- df_paired %>%
group_by(question_content) %>%
group_split()
# 2. 对每一组运行 correlation()
cor_list <- map(grouped, ~ correlation(select(., rel1, rel2), method = "spearman"))
# 3. 加上分组名并组合成一个表
names(cor_list) <- sapply(grouped, function(x) unique(x$question_content))
cor_combined <- bind_rows(cor_list, .id = "question_content")
# 查看
print(cor_combined)
# 查看结果
print(cor_result)
# 计算配对相关性（每种 question_content 一次）
cor_results <- df_paired %>%
group_by(question_content) %>%
summarise(
correlation = cor(rel1, rel2, use = "complete.obs"),
n = n()
)
print(cor_results)
View(df_paired)
# 假设你的数据叫 df，且已加载
df <- read.csv("all_data_srm_all.csv")  # 替换为你的实际路径
# 创建标准 dyad（双向统一）
df <- df %>%
mutate(dyad_std = ifelse(as.character(user_id) < as.character(other_id),
paste(user_id, other_id, sep = "_"),
paste(other_id, user_id, sep = "_")))
# 只保留 measure（或 relationship）两个方向都存在的数据
df_wide <- df %>%
select(dyad_std, user_id, other_id, question_content, measure) %>%
pivot_wider(names_from = user_id, values_from = measure)  # 宽格式转化
# 或者另一种做法：配对并合并成 A→B 和 B→A 两行拼一行
df_paired <- df %>%
select(dyad_std, question_content, user_id, other_id, measure) %>%
group_by(dyad_std, question_content) %>%
filter(n() == 2) %>%
arrange(dyad_std, question_content, user_id) %>%
mutate(pair_id = paste0(dyad_std, "_", question_content)) %>%
summarise(question_content,
rel1 = first(measure),
rel2 = last(measure)
)
library(dplyr)
library(tidyr)
library(tidyverse)
library(dplyr)
library(TripleR)
library(lme4)
library(lmerTest)
library(ggplot2)
library(correlation)
# 假设你的数据叫 df，且已加载
df <- read.csv("all_data_srm_all.csv")  # 替换为你的实际路径
# 创建标准 dyad（双向统一）
df <- df %>%
mutate(dyad_std = ifelse(as.character(user_id) < as.character(other_id),
paste(user_id, other_id, sep = "_"),
paste(other_id, user_id, sep = "_")))
# 只保留 measure（或 relationship）两个方向都存在的数据
df_wide <- df %>%
select(dyad_std, user_id, other_id, question_content, measure) %>%
pivot_wider(names_from = user_id, values_from = measure)  # 宽格式转化
# 或者另一种做法：配对并合并成 A→B 和 B→A 两行拼一行
df_paired <- df %>%
select(dyad_std, question_content, user_id, other_id, measure) %>%
group_by(dyad_std, question_content) %>%
filter(n() == 2) %>%
arrange(dyad_std, question_content, user_id) %>%
mutate(pair_id = paste0(dyad_std, "_", question_content)) %>%
summarise(question_content,
rel1 = first(measure),
rel2 = last(measure)
)
df_paired %>%
ggplot(aes(x = rel1, y = rel2)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "rel1",
breaks = c(1:9)) +
scale_y_continuous(name = " rel2",
breaks = c(1:6))
#存表
write.csv(df_paired, "data/behavior/srm/correlation.csv", row.names = FALSE)
#计算关系
library(ggplot2)
library(correlation)
df <- read.csv("data/behavior/srm/correlation.csv")  # 替换为你的实际路径
df %>%
ggplot(aes(x = rel1, y = rel2)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "rel1",
breaks = c(1:9)) +
scale_y_continuous(name = " rel2",
breaks = c(1:6))
correlation(data = df,
select = "rel1",
select2 = "rel2",
method = "spearman",
alternative = "two.sided")
# 1. 按 question_content 分组
grouped <- df %>%
group_by(question_content) %>%
group_split()
# 2. 对每一组运行 correlation()
cor_list <- map(grouped, ~ correlation(select(., rel1, rel2), method = "spearman"))
# 3. 加上分组名并组合成一个表
names(cor_list) <- sapply(grouped, function(x) unique(x$question_content))
cor_combined <- bind_rows(cor_list, .id = "question_content")
# 查看
print(cor_combined)
df_liked <- df %>%
filter(question_content == "liked")
df_liked %>%
ggplot(aes(x = rel1, y = rel2)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "rel1",
breaks = c(1:9)) +
scale_y_continuous(name = " rel2",
breaks = c(1:6))
correlation(data = df_liked,
select = "rel1",
select2 = "rel2",
method = "spearman",
alternative = "two.sided")
#计算关系
library(ggplot2)
library(correlation)
library(dplyr)
df <- read.csv("data/behavior/srm/correlation.csv")  # 替换为你的实际路径
df %>%
ggplot(aes(x = rel1, y = rel2)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "rel1",
breaks = c(1:9)) +
scale_y_continuous(name = " rel2",
breaks = c(1:6))
correlation(data = df,
select = "rel1",
select2 = "rel2",
method = "spearman",
alternative = "two.sided")
library(purrr)
#去重
df_unique <- df %>%
distinct(dyad_std, question_content, .keep_all = TRUE)
# 1. 按 question_content 分组
grouped <- df_unique %>%
group_by(question_content) %>%
group_split()
# 2. 对每一组运行 correlation()
cor_list <- map(grouped, ~ correlation(select(., rel1, rel2), method = "spearman"))
# 3. 加上分组名并组合成一个表
names(cor_list) <- sapply(grouped, function(x) unique(x$question_content))
cor_combined <- bind_rows(cor_list, .id = "question_content")
# 查看
print(cor_combined)
df_liked <- df %>%
filter(question_content == "liked")
df_liked %>%
ggplot(aes(x = rel1, y = rel2)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "rel1",
breaks = c(1:9)) +
scale_y_continuous(name = " rel2",
breaks = c(1:6))
correlation(data = df_liked,
select = "rel1",
select2 = "rel2",
method = "spearman",
alternative = "two.sided")
#计算liked和other_liked之间的correlation
library(dplyr)
library(tidyr)
df <- read.csv("all_data_df.csv")  # 替换为你的实际路径
#计算liked和other_liked之间的correlation
library(dplyr)
library(tidyr)
df <- read.csv("all_data_df.csv")  # 替换为你的实际路径
#计算liked和other_liked之间的correlation
library(dplyr)
library(tidyr)
df <- read.csv("data/behavior/all_data_df.csv")  # 替换为你的实际路径
# 1. 筛选 liked 和 other_liked
df_filtered <- df %>%
filter(question_content %in% c("liked", "other_liked"))
# 2. 按 dyad + 参与者信息分组，并宽格式转化
df_wide <- df_filtered %>%
group_by(dyad, user_id, other_id, participant_condition, other_condition) %>%
filter(n() == 2) %>%  # 确保 liked 和 other_liked 都存在
select(dyad, user_id, other_id, participant_condition, other_condition,
question_content, measure) %>%
pivot_wider(names_from = question_content, values_from = measure) %>%
drop_na(liked, other_liked)  # 防止有缺失
# 3. 计算相关性（Spearman）
cor_result <- cor(df_wide$liked, df_wide$other_liked,
method = "spearman", use = "complete.obs")
print(cor_result)
View(df_wide)
df_wide %>%
ggplot(aes(x = rel1, y = rel2)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "liked",
breaks = c(1:9)) +
scale_y_continuous(name = " other_liked",
breaks = c(1:6))
#计算liked和other_liked之间的correlation
library(dplyr)
library(tidyr)
df <- read.csv("data/behavior/all_data_df.csv")  # 替换为你的实际路径
# 1. 筛选 liked 和 other_liked
df_filtered <- df %>%
filter(question_content %in% c("liked", "other_liked"))
# 2. 按 dyad + 参与者信息分组，并宽格式转化
df_wide <- df_filtered %>%
group_by(dyad, user_id, other_id, participant_condition, other_condition) %>%
filter(n() == 2) %>%  # 确保 liked 和 other_liked 都存在
select(dyad, user_id, other_id, participant_condition, other_condition,
question_content, measure) %>%
pivot_wider(names_from = question_content, values_from = measure) %>%
drop_na(liked, other_liked)  # 防止有缺失
df_wide %>%
ggplot(aes(x = liked, y = other_liked)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "liked",
breaks = c(1:9)) +
scale_y_continuous(name = " other_liked",
breaks = c(1:6))
correlation(data = df_wide,
select = "liked",
select2 = "other_liked",
method = "spearman",
alternative = "two.sided")
df_wide %>%
ggplot(aes(x = liked, y = other_liked)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "liked",
breaks = c(1:9)) +
scale_y_continuous(name = " other_liked",
breaks = c(1:6))
correlation(data = df_wide,
select = "liked",
select2 = "other_liked",
method = "spearman",
alternative = "two.sided")
correlation(data = df_wide,
select = "liked",
select2 = "other_liked",
method = "spearman",
alternative = "two.sided")
#计算liked和other_liked之间的correlation
library(dplyr)
library(tidyr)
library(correlation)
df <- read.csv("data/behavior/all_data_df.csv")  # 替换为你的实际路径
# 1. 筛选 liked 和 other_liked
df_filtered <- df %>%
filter(question_content %in% c("liked", "other_liked"))
# 2. 按 dyad + 参与者信息分组，并宽格式转化
df_wide <- df_filtered %>%
group_by(dyad, user_id, other_id, participant_condition, other_condition) %>%
filter(n() == 2) %>%  # 确保 liked 和 other_liked 都存在
select(dyad, user_id, other_id, participant_condition, other_condition,
question_content, measure) %>%
pivot_wider(names_from = question_content, values_from = measure) %>%
drop_na(liked, other_liked)  # 防止有缺失
df_wide %>%
ggplot(aes(x = liked, y = other_liked)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "liked",
breaks = c(1:9)) +
scale_y_continuous(name = " other_liked",
breaks = c(1:6))
correlation(data = df_wide,
select = "liked",
select2 = "other_liked",
method = "spearman",
alternative = "two.sided")
#计算liked和other_liked之间的correlation
library(dplyr)
library(tidyr)
library(correlation)
df <- read.csv("data/behavior/all_data_df.csv")  # 替换为你的实际路径
# 1. 筛选 liked 和 other_liked
df_filtered <- df %>%
filter(question_content %in% c("liked", "other_liked"))
# 2. 按 dyad + 参与者信息分组，并宽格式转化
df_wide <- df_filtered %>%
group_by(dyad, user_id, other_id, participant_condition, other_condition) %>%
filter(n() == 2) %>%  # 确保 liked 和 other_liked 都存在
select(dyad, user_id, other_id, participant_condition, other_condition,
question_content, measure) %>%
pivot_wider(names_from = question_content, values_from = measure) %>%
drop_na(liked, other_liked)  # 防止有缺失
df_wide %>%
ggplot(aes(x = liked, y = other_liked)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "liked",
breaks = c(1:9)) +
scale_y_continuous(name = " other_liked",
breaks = c(1:6))
correlation(data = df_wide,
select = "liked",
select2 = "other_liked",
method = "spearman",
alternative = "two.sided")
write.csv(df_paired, "data/behavior/srm/correlation_liked_otherliked.csv", row.names = FALSE)
write.csv(df_wide, "data/behavior/srm/correlation_liked_otherliked.csv", row.names = FALSE)
#correlation  between liked and other_liked
library(ggplot2)
library(correlation)
library(dplyr)
df <- read.csv("data/behavior/srm/correlation_liked_otherliked.csv")  # 替换为你的实际路径
df %>%
ggplot(aes(x = liked, y = other_liked)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "liked",
breaks = c(1:9)) +
scale_y_continuous(name = " other_liked",
breaks = c(1:6))
correlation(data = df,
select = "liked",
select2 = "other_liked",
method = "spearman",
alternative = "two.sided")
#计算condition相同下的同样问题A2B 和B2A的相关性
library(dplyr)
library(tidyr)
# 假设你的原始数据叫 df
df <- read.csv("data/behavior/all_data_df.csv")  # 替换为你的实际路径
# 第一步：为每组构建唯一标识（方便 group_by）
df_grouped <- df %>%
filter(!is.na(measure)) %>%
group_by(dyad, question_content, participant_condition, other_condition) %>%
filter(n() == 2) %>%  # 只保留有两个方向的 dyad（A->B 和 B->A）
arrange(user_id) %>%  # 保证顺序一致
summarise(
rel1 = first(measure),
rel2 = last(measure),
.groups = "drop"
)
View(df_grouped)
#计算condition相同下的同样问题A2B 和B2A的相关性
library(dplyr)
library(tidyr)
# 假设你的原始数据叫 df
df <- read.csv("data/behavior/all_data_df.csv")  # 替换为你的实际路径
# 第一步：为每组构建唯一标识（方便 group_by）
df_grouped <- df %>%
filter(!is.na(measure)) %>%
group_by(dyad, question_content, participant_condition, other_condition) %>%
filter(n() == 2) %>%  # 只保留有两个方向的 dyad（A->B 和 B->A）
arrange(user_id) %>%  # 保证顺序一致
summarise(
rel1 = first(measure),
rel2 = last(measure),
.groups = "drop"
)
#计算condition相同下的同样问题A2B 和B2A的相关性
library(dplyr)
library(tidyr)
# 假设你的原始数据叫 df
df <- read.csv("data/behavior/all_data_df.csv")  # 替换为你的实际路径
# 第一步：为每组构建唯一标识（方便 group_by）
df_grouped <- df %>%
filter(!is.na(measure)) %>%
group_by(dyad, question_content, participant_condition, other_condition) %>%
filter(n() == 2) %>%  # 只保留有两个方向的 dyad（A->B 和 B->A）
arrange(user_id) %>%  # 保证顺序一致
summarise(
rel1 = first(measure),
rel2 = last(measure),
.groups = "drop"
)
#计算condition相同下的同样问题A2B 和B2A的相关性
library(dplyr)
library(tidyr)
# 假设你的原始数据叫 df
df <- read.csv("data/behavior/all_data_df.csv")  # 替换为你的实际路径
# 第一步：为每组构建唯一标识（方便 group_by）
# 创建标准 dyad（双向统一）
df <- df %>%
mutate(dyad_std = ifelse(as.character(user_id) < as.character(other_id),
paste(user_id, other_id, sep = "_"),
paste(other_id, user_id, sep = "_")))
# 只保留 measure（或 relationship）两个方向都存在的数据
df_wide <- df %>%
select(dyad_std, user_id, other_id, question_content, measure) %>%
pivot_wider(names_from = user_id, values_from = measure)  # 宽格式转化
# 或者另一种做法：配对并合并成 A→B 和 B→A 两行拼一行
df_paired <- df %>%
select(dyad_std, question_content, user_id, other_id, measure, participant_condition,other_condition) %>%
group_by(dyad_std, question_content,participant_condition,other_condition) %>%
filter(n() == 2) %>%
arrange(dyad_std, question_content, user_id) %>%
mutate(pair_id = paste0(dyad_std, "_", question_content)) %>%
summarise(question_content,
rel1 = first(measure),
rel2 = last(measure)
)
View(df_paired)
#计算condition相同下的同样问题A2B 和B2A的相关性
library(dplyr)
library(tidyr)
# 假设你的原始数据叫 df
df <- read.csv("data/behavior/all_data_df.csv")  # 替换为你的实际路径
# 第一步：为每组构建唯一标识（方便 group_by）
# 创建标准 dyad（双向统一）
df <- df %>%
mutate(dyad_std = ifelse(as.character(user_id) < as.character(other_id),
paste(user_id, other_id, sep = "_"),
paste(other_id, user_id, sep = "_")))
# 只保留 measure（或 relationship）两个方向都存在的数据
df_wide <- df %>%
select(dyad_std, user_id, other_id, question_content, measure) %>%
pivot_wider(names_from = user_id, values_from = measure)  # 宽格式转化
# 或者另一种做法：配对并合并成 A→B 和 B→A 两行拼一行
df_paired <- df %>%
select(dyad_std, question_content, user_id, other_id, measure, participant_condition,other_condition) %>%
group_by(dyad_std, question_content,participant_condition,other_condition) %>%
filter(n() == 2) %>%
arrange(dyad_std, question_content, user_id) %>%
mutate(pair_id = paste0(dyad_std, "_", question_content)) %>%
summarise(question_content,
rel1 = first(measure),
rel2 = last(measure)
)
#存表
write.csv(df_paired, "data/behavior/srm/correlation_samecondition.csv", row.names = FALSE)
#计算相同条件下的相关性
library(purrr)
df <- read.csv("data/behavior/srm/correlation_samecondition.csv")  # 替换为你的实际路径
#去重
df_unique <- df %>%
distinct(dyad_std, question_content, .keep_all = TRUE)
# 1. 按 question_content 分组
grouped <- df_unique %>%
group_by(question_content) %>%
group_split()
# 2. 对每一组运行 correlation()
cor_list <- map(grouped, ~ correlation(select(., rel1, rel2), method = "spearman"))
#计算相同条件下的相关性
library(purrr)
df <- read.csv("data/behavior/srm/correlation_samecondition.csv")  # 替换为你的实际路径
#去重
df_unique <- df %>%
distinct(dyad_std, question_content, .keep_all = TRUE)
# 1. 按 question_content 分组
grouped <- df_unique %>%
group_by(question_content) %>%
group_split()
# 2. 对每一组运行 correlation()
cor_list <- map(grouped, ~ correlation(select(., rel1, rel2), method = "spearman"))
print(cor_list)
