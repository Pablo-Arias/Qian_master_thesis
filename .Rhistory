df <- read.csv("data/behavior/all_data_df.csv")  # 替换为你的实际路径
# 第一步：为每组构建唯一标识（方便 group_by）
df_grouped <- df %>%
filter(!is.na(measure)) %>%
group_by(dyad, question_content, participant_condition, other_condition) %>%
filter(n() == 2) %>%  # 只保留有两个方向的 dyad（A->B 和 B->A）
arrange(user_id) %>%  # 保证顺序一致
summarise(
rel1 = first(measure),
rel2 = last(measure),
.groups = "drop"
)
View(df_grouped)
#计算condition相同下的同样问题A2B 和B2A的相关性
library(dplyr)
library(tidyr)
# 假设你的原始数据叫 df
df <- read.csv("data/behavior/all_data_df.csv")  # 替换为你的实际路径
# 第一步：为每组构建唯一标识（方便 group_by）
df_grouped <- df %>%
filter(!is.na(measure)) %>%
group_by(dyad, question_content, participant_condition, other_condition) %>%
filter(n() == 2) %>%  # 只保留有两个方向的 dyad（A->B 和 B->A）
arrange(user_id) %>%  # 保证顺序一致
summarise(
rel1 = first(measure),
rel2 = last(measure),
.groups = "drop"
)
#计算condition相同下的同样问题A2B 和B2A的相关性
library(dplyr)
library(tidyr)
# 假设你的原始数据叫 df
df <- read.csv("data/behavior/all_data_df.csv")  # 替换为你的实际路径
# 第一步：为每组构建唯一标识（方便 group_by）
df_grouped <- df %>%
filter(!is.na(measure)) %>%
group_by(dyad, question_content, participant_condition, other_condition) %>%
filter(n() == 2) %>%  # 只保留有两个方向的 dyad（A->B 和 B->A）
arrange(user_id) %>%  # 保证顺序一致
summarise(
rel1 = first(measure),
rel2 = last(measure),
.groups = "drop"
)
#计算condition相同下的同样问题A2B 和B2A的相关性
library(dplyr)
library(tidyr)
# 假设你的原始数据叫 df
df <- read.csv("data/behavior/all_data_df.csv")  # 替换为你的实际路径
# 第一步：为每组构建唯一标识（方便 group_by）
# 创建标准 dyad（双向统一）
df <- df %>%
mutate(dyad_std = ifelse(as.character(user_id) < as.character(other_id),
paste(user_id, other_id, sep = "_"),
paste(other_id, user_id, sep = "_")))
# 只保留 measure（或 relationship）两个方向都存在的数据
df_wide <- df %>%
select(dyad_std, user_id, other_id, question_content, measure) %>%
pivot_wider(names_from = user_id, values_from = measure)  # 宽格式转化
# 或者另一种做法：配对并合并成 A→B 和 B→A 两行拼一行
df_paired <- df %>%
select(dyad_std, question_content, user_id, other_id, measure, participant_condition,other_condition) %>%
group_by(dyad_std, question_content,participant_condition,other_condition) %>%
filter(n() == 2) %>%
arrange(dyad_std, question_content, user_id) %>%
mutate(pair_id = paste0(dyad_std, "_", question_content)) %>%
summarise(question_content,
rel1 = first(measure),
rel2 = last(measure)
)
View(df_paired)
#计算condition相同下的同样问题A2B 和B2A的相关性
library(dplyr)
library(tidyr)
# 假设你的原始数据叫 df
df <- read.csv("data/behavior/all_data_df.csv")  # 替换为你的实际路径
# 第一步：为每组构建唯一标识（方便 group_by）
# 创建标准 dyad（双向统一）
df <- df %>%
mutate(dyad_std = ifelse(as.character(user_id) < as.character(other_id),
paste(user_id, other_id, sep = "_"),
paste(other_id, user_id, sep = "_")))
# 只保留 measure（或 relationship）两个方向都存在的数据
df_wide <- df %>%
select(dyad_std, user_id, other_id, question_content, measure) %>%
pivot_wider(names_from = user_id, values_from = measure)  # 宽格式转化
# 或者另一种做法：配对并合并成 A→B 和 B→A 两行拼一行
df_paired <- df %>%
select(dyad_std, question_content, user_id, other_id, measure, participant_condition,other_condition) %>%
group_by(dyad_std, question_content,participant_condition,other_condition) %>%
filter(n() == 2) %>%
arrange(dyad_std, question_content, user_id) %>%
mutate(pair_id = paste0(dyad_std, "_", question_content)) %>%
summarise(question_content,
rel1 = first(measure),
rel2 = last(measure)
)
#存表
write.csv(df_paired, "data/behavior/srm/correlation_samecondition.csv", row.names = FALSE)
#计算相同条件下的相关性
library(purrr)
df <- read.csv("data/behavior/srm/correlation_samecondition.csv")  # 替换为你的实际路径
#去重
df_unique <- df %>%
distinct(dyad_std, question_content, .keep_all = TRUE)
# 1. 按 question_content 分组
grouped <- df_unique %>%
group_by(question_content) %>%
group_split()
# 2. 对每一组运行 correlation()
cor_list <- map(grouped, ~ correlation(select(., rel1, rel2), method = "spearman"))
#计算相同条件下的相关性
library(purrr)
df <- read.csv("data/behavior/srm/correlation_samecondition.csv")  # 替换为你的实际路径
#去重
df_unique <- df %>%
distinct(dyad_std, question_content, .keep_all = TRUE)
# 1. 按 question_content 分组
grouped <- df_unique %>%
group_by(question_content) %>%
group_split()
# 2. 对每一组运行 correlation()
cor_list <- map(grouped, ~ correlation(select(., rel1, rel2), method = "spearman"))
print(cor_list)
# 看relationship的分布
#画图
# 加载必要包
library(ggplot2)
library(dplyr)
# 读取数据（假设你已经用 read.csv() 读入为 df）
df <- read.csv("all_data_srm_all.csv")
ggplot(df, aes(x = question_content, y = relationship)) +
geom_boxplot(fill = "lightblue", alpha = 0.7) +
geom_jitter(width = 0.2, alpha = 0.4, color = "black") +
theme_minimal() +
labs(title = "measure.p by Question Content",
x = "Question Content",
y = "relationship")
# 看relationship的分布
#画图
# 加载必要包
library(ggplot2)
library(dplyr)
# 读取数据（假设你已经用 read.csv() 读入为 df）
df <- read.csv("all_data_srm_all.csv")
ggplot(df, aes(x = question_content, y = relationship)) +
geom_boxplot(fill = "lightblue", alpha = 0.7) +
geom_jitter(width = 0.2, alpha = 0.4, color = "black") +
theme_minimal() +
labs(title = "relationship by Question Content",
x = "Question Content",
y = "relationship")
#计算condition相同下的同样问题A2B 和B2A的相关
library(purrr)
df <- read.csv("data/behavior/srm/correlation_samecondition.csv")  # 替换为你的实际路径
#去重
df_unique <- df %>%
distinct(dyad_std, question_content, .keep_all = TRUE)
#correlation  between liked and other_liked
library(ggplot2)
library(correlation)
library(dplyr)
df <- read.csv("data/behavior/srm/correlation_liked_otherliked.csv")  # 替换为你的实际路径
df %>%
ggplot(aes(x = liked, y = other_liked)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "liked",
breaks = c(1:9)) +
scale_y_continuous(name = " other_liked",
breaks = c(1:6))
correlation(data = df,
select = "liked",
select2 = "other_liked",
method = "spearman",
alternative = "two.sided")
#画图
# 加载必要包
library(ggplot2)
library(dplyr)
# 读取数据（假设你已经用 read.csv() 读入为 df）
df <- read.csv("all_data_srm_all.csv")
ggplot(df, aes(x = question_content, y = measure.p)) +
geom_boxplot(fill = "lightblue", alpha = 0.7) +
geom_jitter(width = 0.2, alpha = 0.4, color = "black") +
theme_minimal() +
labs(title = "measure.p by Question Content",
x = "Question Content",
y = "measure.p")
#柱状图
# 读取数据（假设你已将数据读入为 df）
df <- read.csv("all_data_srm_unique.csv")
# 加载必要包
library(ggplot2)
library(dplyr)
# 假设你的数据框名为 df
# 1. 计算每个 question_content 的平均值
mean_df <- df %>%
group_by(question_content) %>%
summarise(mean_measure_p = mean(measure.t, na.rm = TRUE))
View(mean_df)
ggplot(mean_df, aes(x = question_content, y = mean_measure_p)) +
geom_col(fill = "skyblue") +
geom_text(aes(label = signif(mean_measure_p, 3)), vjust = -0.5) +
theme_minimal() +
labs(title = "Mean of measure.p by Question Content",
x = "Question Content",
y = "Mean of measure.p") +
coord_cartesian(ylim = c(-0.01, 0.01)) +  # 手动设置y轴范围
theme(axis.text.x = element_text(angle = 45, hjust = 1))
#correlation
# 1. 加载包
library(tidyverse)
library(dplyr)
library(TripleR)
library(lme4)
library(lmerTest)
library(ggplot2)
library(correlation)
# 2. 假设数据已读入为 df
df <- read_csv("../Dissertation/all_data_df.csv")
# correlation  between measure.p and measure.t
#install.packages("correlation")  # 如果还没装
library(correlation)
df <- read_csv("all_data_srm_unique.csv")
df %>%
ggplot(aes(x = measure.p, y = measure.t)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "measure.p",
breaks = c(1:9)) +
scale_y_continuous(name = " measure.t",
breaks = c(1:6))
correlation(data = df,
select = "measure.p",
select2 = "measure.t",
method = "spearman",
alternative = "two.sided")
# 看relationship的分布
#画图
# 加载必要包
library(ggplot2)
library(dplyr)
# 读取数据（假设你已经用 read.csv() 读入为 df）
df <- read.csv("all_data_srm_all.csv")
ggplot(df, aes(x = question_content, y = relationship)) +
geom_boxplot(fill = "lightblue", alpha = 0.7) +
geom_jitter(width = 0.2, alpha = 0.4, color = "black") +
theme_minimal() +
labs(title = "relationship by Question Content",
x = "Question Content",
y = "relationship")
#calculate correlation
library(dplyr)
library(tidyr)
# 假设你的数据叫 df，且已加载
df <- read.csv("all_data_srm_all.csv")  # 替换为你的实际路径
# 创建标准 dyad（双向统一）
df <- df %>%
mutate(dyad_std = ifelse(as.character(user_id) < as.character(other_id),
paste(user_id, other_id, sep = "_"),
paste(other_id, user_id, sep = "_")))
# 只保留 measure（或 relationship）两个方向都存在的数据
df_wide <- df %>%
select(dyad_std, user_id, other_id, question_content, measure) %>%
pivot_wider(names_from = user_id, values_from = measure)  # 宽格式转化
# 或者另一种做法：配对并合并成 A→B 和 B→A 两行拼一行
df_paired <- df %>%
select(dyad_std, question_content, user_id, other_id, measure) %>%
group_by(dyad_std, question_content) %>%
filter(n() == 2) %>%
arrange(dyad_std, question_content, user_id) %>%
mutate(pair_id = paste0(dyad_std, "_", question_content)) %>%
summarise(
rel1 = first(measure),
rel2 = last(measure)
)
# 计算配对相关性（每种 question_content 一次）
cor_results <- df_paired %>%
group_by(question_content) %>%
summarise(
correlation = cor(rel1, rel2, use = "complete.obs"),
n = n()
)
print(cor_results)
ggplot(df_paired, aes(x = rel1, y = rel2)) +
geom_point(alpha = 0.6, color = "orange") +
geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
labs(title = "Reciprocal Relationship Scores: A→B vs B→A",
x = "A to B (relationship score)",
y = "B to A (relationship score)") +
theme_minimal()
library(ggplot2)
ggplot(df_paired, aes(x = rel1, y = rel2)) +
geom_point(alpha = 0.6, color = "orange") +
geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
facet_wrap(~ question_content) +  # 按问题类型分面
labs(
title = "Reciprocal Relationship Scores by Question Content",
x = "A to B (relationship score)",
y = "B to A (relationship score)"
) +
theme_minimal()
#install.packages("ggpubr")  # 只需一次
library(ggpubr)
ggplot(df_paired, aes(x = rel1, y = rel2)) +
geom_point(alpha = 0.6, color = "orange") +
geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
stat_cor(method = "spearman", label.x = -2.5, label.y = 2.5) +  # 添加相关系数
facet_wrap(~ question_content) +
labs(
title = "Reciprocal Relationship (Spearman r) by Question Content",
x = "A to B (relationship score)",
y = "B to A (relationship score)"
) +
theme_minimal()
library(correlation)
df_paired %>%
ggplot(aes(x = measure.p, y = measure.t)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "measure.p",
breaks = c(1:9)) +
scale_y_continuous(name = " measure.t",
breaks = c(1:6))
#correlation  同一组AtoB 和Bto A
#calculate correlation
library(dplyr)
library(tidyr)
library(tidyverse)
library(dplyr)
library(TripleR)
library(lme4)
library(lmerTest)
library(ggplot2)
library(correlation)
# 假设你的数据叫 df，且已加载
df <- read.csv("all_data_srm_all.csv")  # 替换为你的实际路径
# 创建标准 dyad（双向统一）
df <- df %>%
mutate(dyad_std = ifelse(as.character(user_id) < as.character(other_id),
paste(user_id, other_id, sep = "_"),
paste(other_id, user_id, sep = "_")))
# 只保留 measure（或 relationship）两个方向都存在的数据
df_wide <- df %>%
select(dyad_std, user_id, other_id, question_content, measure) %>%
pivot_wider(names_from = user_id, values_from = measure)  # 宽格式转化
# 或者另一种做法：配对并合并成 A→B 和 B→A 两行拼一行
df_paired <- df %>%
select(dyad_std, question_content, user_id, other_id, measure) %>%
group_by(dyad_std, question_content) %>%
filter(n() == 2) %>%
arrange(dyad_std, question_content, user_id) %>%
mutate(pair_id = paste0(dyad_std, "_", question_content)) %>%
summarise(question_content,
rel1 = first(measure),
rel2 = last(measure)
)
df_paired %>%
ggplot(aes(x = rel1, y = rel2)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "rel1",
breaks = c(1:9)) +
scale_y_continuous(name = " rel2",
breaks = c(1:6))
#存表
write.csv(df_paired, "data/behavior/srm/correlation.csv", row.names = FALSE)
correlation(data = df_paired,
select = "rel1",
select2 = "rel2",
method = "spearman",
alternative = "two.sided")
library(correlation)
# 只取你要分析的列，构建一个简洁数据框
rel_data  <- df_paired %>% select(rel1, rel2)
# 使用 correlation() 明确说明列名，不让它自动分组
cor_result <- correlation(
data = rel_data,
method = "spearman"
)
print(cor_result)
library(purrr)
# 1. 按 question_content 分组
grouped <- df_paired %>%
group_by(question_content) %>%
group_split()
# 2. 对每一组运行 correlation()
cor_list <- map(grouped, ~ correlation(select(., rel1, rel2), method = "spearman"))
# 3. 加上分组名并组合成一个表
names(cor_list) <- sapply(grouped, function(x) unique(x$question_content))
cor_combined <- bind_rows(cor_list, .id = "question_content")
# 查看
print(cor_combined)
# 查看结果
print(cor_result)
# 计算配对相关性（每种 question_content 一次）
cor_results <- df_paired %>%
group_by(question_content) %>%
summarise(
correlation = cor(rel1, rel2, use = "complete.obs"),
n = n()
)
print(cor_results)
#计算condition相同下的同样问题A2B 和B2A的相关
library(purrr)
df <- read.csv("data/behavior/srm/correlation_samecondition.csv")  # 替换为你的实际路径
#去重
df_unique <- df %>%
distinct(dyad_std, question_content, .keep_all = TRUE)
# 1. 按 question_content 分组
grouped <- df_unique %>%
group_by(question_content) %>%
group_split()
# 2. 对每一组运行 correlation()
cor_list <- map(grouped, ~ correlation(select(., rel1, rel2), method = "spearman"))
print(cor_list)
# correlation  between measure.p and measure.t
#install.packages("correlation")  # 如果还没装
library(correlation)
df <- read_csv("all_data_srm_unique.csv")
df %>%
ggplot(aes(x = measure.p, y = measure.t)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "measure.p",
breaks = c(1:9)) +
scale_y_continuous(name = " measure.t",
breaks = c(1:6))
correlation(data = df,
select = "measure.p",
select2 = "measure.t",
method = "spearman",
alternative = "two.sided")
# 1. 按 question_content 分组
grouped <- df %>%
group_by(question_content) %>%
group_split()
# 2. 对每一组运行 correlation()
cor_list <- map(grouped, ~ correlation(select(., rel1, rel2), method = "spearman"))
# correlation  between measure.p and measure.t
#install.packages("correlation")  # 如果还没装
library(correlation)
df <- read_csv("all_data_srm_unique.csv")
df %>%
ggplot(aes(x = measure.p, y = measure.t)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "measure.p",
breaks = c(1:9)) +
scale_y_continuous(name = " measure.t",
breaks = c(1:6))
correlation(data = df,
select = "measure.p",
select2 = "measure.t",
method = "spearman",
alternative = "two.sided")
library(purrr)
# 1. 按 question_content 分组
grouped <- df %>%
group_by(question_content) %>%
group_split()
# 2. 对每一组运行 correlation()
cor_list <- map(grouped, ~ correlation(select(., rel1, rel2), method = "spearman"))
# correlation  between measure.p and measure.t
#install.packages("correlation")  # 如果还没装
library(correlation)
df <- read_csv("all_data_srm_unique.csv")
df %>%
ggplot(aes(x = measure.p, y = measure.t)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "measure.p",
breaks = c(1:9)) +
scale_y_continuous(name = " measure.t",
breaks = c(1:6))
correlation(data = df,
select = "measure.p",
select2 = "measure.t",
method = "spearman",
alternative = "two.sided")
# 1. 按 question_content 分组
grouped <- df %>%
group_by(question_content) %>%
group_split()
# 2. 对每一组运行 correlation()
cor_list <- map(grouped, ~ correlation(select(., measure.p, measure.t), method = "spearman"))
# correlation  between measure.p and measure.t
#install.packages("correlation")  # 如果还没装
library(correlation)
df <- read_csv("all_data_srm_unique.csv")
df %>%
ggplot(aes(x = measure.p, y = measure.t)) +
geom_point() +
geom_smooth(method = "lm") +
scale_x_continuous(name = "measure.p",
breaks = c(1:9)) +
scale_y_continuous(name = " measure.t",
breaks = c(1:6))
correlation(data = df,
select = "measure.p",
select2 = "measure.t",
method = "spearman",
alternative = "two.sided")
# 1. 按 question_content 分组
grouped <- df %>%
group_by(question_content) %>%
group_split()
# 2. 对每一组运行 correlation()
cor_list <- map(grouped, ~ correlation(select(., measure.p, measure.t), method = "spearman"))
print(cor_list)
